function findInitial() {
    const verticesInInitial = [];
    for (let i = 0; i < Object.keys(state.Vertices).length; i++) {
        if (state.Vertices[Object.keys(state.Vertices)[i]].x < 125) {
            verticesInInitial.push(state.Vertices[Object.keys(state.Vertices)[i]].id);
        }
    }
    return verticesInInitial
}

function findFinal() {
    const verticesInFinal = [];
    for (let i = 0; i < Object.keys(state.Vertices).length; i++) {
        if (state.Vertices[Object.keys(state.Vertices)[i]].x > 575) {
            verticesInFinal.push(state.Vertices[Object.keys(state.Vertices)[i]].id);
        }
    }
    return verticesInFinal
}





function checker() {
    resetErrors();
    state.floatingErrors = [];
    state.numberedErrors = [];


    /*Initial and final state checks*/
    const initialVertices = findInitial();
    const initialCharge = 0;
    if (initialVertices.length === 0) {
        state.floatingErrors.push("No Particles In the initial State")
    }
    for (let i = 0; i < initialVertices.length; i++) {
        if (state.Vertices[initialVertices[i]].connections.length === 1) {
        } else {
            state.numberedErrors.push({'error':"Vertices in the initial state must only have 1 Connection",'id':state.Vertices[Object.keys(state.Vertices)[i]].id})
        }

    }
    const finalVertices = findFinal();
    const finalCharge = 0;
    if (finalVertices.length === 0) {
        state.floatingErrors.push("No Particles In the final State")
    }

    for (let i = 0; i < finalVertices.length; i++) {
        if (state.Vertices[finalVertices[i]].connections.length === 1) {
        } else {
            state.numberedErrors.push({'error':"Vertices in the Final state must only have 1 Connection",'id':state.Vertices[Object.keys(state.Vertices)[i]].id})

        }
    }

    const initialAndFinalVertices = initialVertices.concat(finalVertices);
    /*Rest of the Vertices*/

    for (let i = 0; i < Object.keys(state.Vertices).length; i++) {
        if (!(initialAndFinalVertices.includes(Number(Object.keys(state.Vertices)[i])))) {
            if (state.Vertices[Object.keys(state.Vertices)[i]].connections.length >= 5) {
                state.numberedErrors.push({'error':"No vertex should have more than 4 connections",'id':state.Vertices[Object.keys(state.Vertices)[i]].id})

            }
            if (state.Vertices[Object.keys(state.Vertices)[i]].connections.length === 4) {
                


            }
            if (state.Vertices[Object.keys(state.Vertices)[i]].connections.length === 3) {
                //condense info in this loop to checkable form.
                var fermions = 0;
                var bosons = 0;
                for(let j=0;j<state.Vertices[Object.keys(state.Vertices)[i]].connections.length;j++){
                    var particle = state.Particles[state.Vertices[Object.keys(state.Vertices)[i]].connections[j]]
                    if(isBoson(particle.name)){
                        bosons +=1
                    }else{
                        fermions +=1
                    }
                }


                if(bosons===1 && fermions ===2){
                    console.log("this is normal")
                }else if(bosons === 3){
                    console.log("this is niche")
                }else{
                    state.numberedErrors.push({'error':"This is not an allowed fundamental vertex",'id':state.Vertices[Object.keys(state.Vertices)[i]].id})
                }
                
                
               

            }
            if (state.Vertices[Object.keys(state.Vertices)[i]].connections.length === 2) {

                state.numberedErrors.push({'error':"No vertex should have just 2 connections",'id':state.Vertices[Object.keys(state.Vertices)[i]].id})

            }
            if (state.Vertices[Object.keys(state.Vertices)[i]].connections.length === 1) {
                state.numberedErrors.push({'error':"No vertex outside final or initial states should have just 1 connection",'id':state.Vertices[Object.keys(state.Vertices)[i]].id})

            }
        }
    }
    if (state.floatingErrors.length ===0 && state.numberedErrors.length ===0){
        document.getElementById('workingCanvas').style.backgroundColor = "#ade6ad"; //green for subtle feedback 
    }else{
        document.getElementById('workingCanvas').style.backgroundColor = "#e6adad"; //red
    }
    errorGenerator("floatingErrorContainer",state.floatingErrors);
    errorGenerator("numberedErrorContainer", state.numberedErrors);
}

function compare(a,b) {
    if (a.id < b.id)
       return -1;
    if (a.id > b.id)
      return 1;
    return 0;
  }

function errorGenerator(targetContainer, errors) {
    if(targetContainer === "floatingErrorContainer"){
        const container = document.getElementById(targetContainer);
        container.innerHTML = '';
        errors.forEach(err => {
            const row = document.createElement("li");
            row.innerText = err;
            container.appendChild(row);
        });
    }else{
        const container = document.getElementById(targetContainer);
        document.getElementById("numberedErrorContainer").innerHTML='';
        errors.sort(compare);
        console.log(errors);
        var counter = 1
        for (var i=0;i<errors.length;i++){
         if(i===0){
            state.Vertices[errors[i].id].drawLabel(counter);
         }
         var row = document.createElement("div");
         row.className = "row";
         var col = document.createElement("div");
         col.className = "col-12";
         if(i!=0 && errors[i].id != errors[i-1].id){
             counter +=1;
             state.Vertices[errors[i].id].drawLabel(counter);
         }
         col.innerText = counter +")"+ errors[i].error;
         row.appendChild(col);
         document.getElementById("errorContainer").appendChild(row);
        }
    }
}

function resetErrors(){
    state.floatingErrors = [];
    state.numberedErrors = [];
    errorGenerator("floatingErrorContainer",state.floatingErrors);
    errorGenerator("numberedErrorContainer", state.numberedErrors);
}

function resetStage() {
    console.log("reset");
    for(var i=0;i<Object.keys(state.Vertices).length;i++){
        state.Vertices[Object.keys(state.Vertices)[i]].destroy();
    }
    for(var i=0;i<Object.keys(state.Particles).length;i++){
        state.Particles[Object.keys(state.Particles)[i]].destroy();
    }
    document.getElementById('workingCanvas').style.backgroundColor = "lightblue";
    state.globalState = "None";
    state.vertexID = getVertexID();
    state.particleID = getParticleID();
    state.Particles = {}
    state.Vertices= {}
    state.selectedVertexId=  null
    state.selectedParticleId= null
    state.drawFlavour =  state.drawFlavour
    state.offset = {"top":document.getElementById("workingCanvas").getBoundingClientRect().top, "left":document.getElementById("workingCanvas").getBoundingClientRect().left}
    errorGenerator("floatingErrorContainer",state.floatingErrors);
    errorGenerator("numberedErrorContainer", state.numberedErrors);
      
  }

  function resetAll(){
      resetStage();
      resetErrors();
  }

